const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const { initializeApp } = require('firebase/app');
const { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion } = require('firebase/firestore');
require('dotenv').config();

// --- CONFIGURACIÓN DE FIREBASE ---
const firebaseConfig = {
    apiKey: process.env.FIREBASE_API_KEY,
    authDomain: process.env.FIREBASE_AUTH_DOMAIN,
    databaseURL: process.env.FIREBASE_DATABASE_URL,
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
    appId: process.env.FIREBASE_APP_ID
};

const fbApp = initializeApp(firebaseConfig);
const db = getFirestore(fbApp);
const appId = 'bridgetime-v1';

// --- INICIALIZACIÓN DEL SERVIDOR ---
const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*" } 
});

// Estado en memoria: Guardamos los datos activos aquí para máxima velocidad (RAM)
let realms = {};

// --- LÓGICA DE SOCKETS ---
io.on('connection', (socket) => {
    let currentRealm = null;
    let userName = "Anónimo";

    console.log(`[CONEXIÓN] Nuevo usuario conectado: ${socket.id}`);

    // Unirse a un reino (Bridge ID)
    socket.on('join_realm', async (data) => {
        const { realmId, name } = data;
        currentRealm = realmId;
        userName = name || "Pleb";
        
        socket.join(realmId);
        console.log(`[REINO] ${userName} se unió a ${realmId}`);

        try {
            // Si el reino no está en la memoria RAM, lo buscamos en Firebase
            if (!realms[realmId]) {
                console.log(`[DB] Buscando reino ${realmId} en Firebase...`);
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
                const snap = await getDoc(docRef);
                
                if (snap.exists()) {
                    realms[realmId] = snap.data();
                } else {
                    // Si el reino es nuevo, creamos la estructura base
                    realms[realmId] = { 
                        tiles: [], 
                        princessBehavior: 'normal',
                        lastUpdate: Date.now()
                    };
                    await setDoc(docRef, realms[realmId]);
                }
            }

            // Enviar el estado actual solo al jugador que acaba de entrar
            socket.emit('init_state', realms[realmId]);
            
            // Notificar a otros en el reino
            socket.to(realmId).emit('chat_message', {
                user: 'SISTEMA',
                text: `${userName} ha entrado al reino.`
            });

        } catch (error) {
            console.error("[ERROR JOIN]", error);
            socket.emit('error_msg', "Error al cargar el reino.");
        }
    });

    // Construcción de bloques (Tiempo Real)
    socket.on('build_block', async (data) => {
        const { realmId, m, by } = data;
        const newTile = { m, by, t: Date.now() };
        
        if (realms[realmId]) {
            // 1. Actualizar memoria RAM inmediatamente
            realms[realmId].tiles.push(newTile);
            realms[realmId].lastUpdate = Date.now();
            
            // 2. Emitir a TODOS en el reino (incluyendo al emisor para confirmar)
            io.to(realmId).emit('update_tiles', realms[realmId].tiles);

            // 3. Guardar en Firebase (Persistencia)
            // Lo hacemos de forma asíncrona para no bloquear el juego
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
            updateDoc(docRef, { 
                tiles: arrayUnion(newTile) 
            }).catch(err => {
                console.error("[DB SAVE ERROR]", err);
                // Si falla el update (quizás no existe el doc), intentamos setDoc completo
                setDoc(docRef, realms[realmId]);
            });
        }
    });

    // Control de la Princesa (Solo para el rol Queen/Princess)
    socket.on('set_princess', (data) => {
        const { realmId, behavior } = data;
        if (realms[realmId]) {
            realms[realmId].princessBehavior = behavior;
            realms[realmId].lastUpdate = Date.now();

            // Sincronizar comportamiento con todos
            io.to(realmId).emit('update_princess', behavior);
            
            // Guardar en Firebase
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
            updateDoc(docRef, { princessBehavior: behavior }).catch(e => console.error(e));
        }
    });

    // Chat Multijugador
    socket.on('send_chat', (data) => {
        if (currentRealm) {
            io.to(currentRealm).emit('chat_message', {
                user: userName,
                text: data.text
            });
        }
    });

    // Desconexión
    socket.on('disconnect', () => {
        if (currentRealm) {
            console.log(`[LOGOUT] ${userName} salió de ${currentRealm}`);
        }
    });
});

// --- TAREA DE MANTENIMIENTO ---
// Cada 30 minutos, limpiamos de la memoria RAM los reinos que no han tenido actividad
// para que el servidor de Render no se sature. Los datos siguen seguros en Firebase.
setInterval(() => {
    const now = Date.now();
    Object.keys(realms).forEach(id => {
        if (now - realms[id].lastUpdate > 30 * 60 * 1000) {
            console.log(`[LIMPIEZA] Liberando RAM del reino inactivo: ${id}`);
            delete realms[id];
        }
    });
}, 15 * 60 * 1000);

// --- INICIO DEL SERVIDOR ---
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`-------------------------------------------`);
    console.log(` BRIDGE TIME ENGINE - ONLINE 24/7 `);
    console.log(` Puerto: ${PORT} `);
    console.log(`-------------------------------------------`);
});
