const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const { initializeApp } = require('firebase/app');
const { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion } = require('firebase/firestore');
require('dotenv').config();

// Configuración de Firebase desde variables de entorno de Render
const firebaseConfig = {
    apiKey: process.env.FIREBASE_API_KEY,
    authDomain: process.env.FIREBASE_AUTH_DOMAIN,
    databaseURL: process.env.FIREBASE_DATABASE_URL,
    projectId: process.env.FIREBASE_PROJECT_ID,
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
    messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
    appId: process.env.FIREBASE_APP_ID
};

const fbApp = initializeApp(firebaseConfig);
const db = getFirestore(fbApp);
const appId = 'bridgetime-v1';

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: "*" } // Permite conexión desde GitHub Pages / Localhost
});

// Estado en memoria para velocidad ultra rápida
let realms = {};

io.on('connection', (socket) => {
    console.log('Usuario conectado:', socket.id);

    // Unirse a un reino específico (Bridge ID)
    socket.on('join_realm', async (realmId) => {
        socket.join(realmId);
        
        // Si no está en memoria, intentar traer de Firebase
        if (!realms[realmId]) {
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
            const snap = await getDoc(docRef);
            if (snap.exists()) {
                realms[realmId] = snap.data();
            } else {
                realms[realmId] = { tiles: [], princessBehavior: 'normal' };
            }
        }
        
        // Enviar estado actual al jugador que entra
        socket.emit('init_state', realms[realmId]);
    });

    // Construcción de bloques
    socket.on('build_block', async (data) => {
        const { realmId, m, by } = data;
        const newTile = { m, by, t: Date.now() };
        
        if (realms[realmId]) {
            realms[realmId].tiles.push(newTile);
            
            // Sincronizar con todos los del reino inmediatamente
            io.to(realmId).emit('update_tiles', realms[realmId].tiles);

            // Guardar en Firebase en segundo plano (asíncrono)
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
            updateDoc(docRef, { 
                tiles: arrayUnion(newTile) 
            }).catch(() => setDoc(docRef, realms[realmId]));
        }
    });

    // Comportamiento de la Princesa
    socket.on('set_princess', (data) => {
        const { realmId, behavior } = data;
        if (realms[realmId]) {
            realms[realmId].princessBehavior = behavior;
            io.to(realmId).emit('update_princess', behavior);
            
            // Actualizar Firebase
            const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'realms', realmId);
            updateDoc(docRef, { princessBehavior: behavior });
        }
    });

    socket.on('disconnect', () => {
        console.log('Usuario desconectado');
    });
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`Servidor de Bridge Time activo en puerto ${PORT}`);
});
